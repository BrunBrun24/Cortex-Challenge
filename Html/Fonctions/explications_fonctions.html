<!DOCTYPE html>
<html lang="fr">
<head>
    <title>Fonctions</title>
    <link rel="stylesheet" type="text/css" href="../style_all.css">
    <link rel="stylesheet" type="text/css" href="../boxs_all.css">
    <link rel="stylesheet" type="text/css" href="../cube_all.css">
    <link rel="stylesheet" type="text/css" href="menues_explications_fonctions.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

    <h1>Explications des fonctions utilisées</h1>

    <div class="container">
        <div class="box">
            <span></span>
            <div class="content1">
                <h2>Accueil</h2>
                <a href="../../index.html">Read More</a>
            </div>
        </div>
    
        <div class="box">
            <span></span>
            <div class="content">
                <h2>Groupe</h2>
                <p>"Lors de la réalisation de notre projet à deux, nous avons adopté une approche organisée pour travailler de manière efficace malgré la distance. Nous avons utilisé ..."</p>
                <a href="../Groupe/groupe.html">Read More</a>
            </div>
        </div>
    
        <div class="box">
            <span></span>
            <div class="content">
                <h2>Sujet</h2>
                <p>"Le jeu Cortex risque de vous brûler les méninges! Ce jeu de réflexion et de rapidité va vous lancer des défis à la fois ludiques et éducatifs autour de 8 épreuves ..."</p>
                <a href="../Sujet/sujet.html">Read More</a>
            </div>
        </div>

        <div class="box">
            <span></span>
            <div class="content">
                <h2>Fonctions</h2>
                <p>"En comparant les deux fonctions, elles effectuent essentiellement les mêmes opérations pour trouver le premier nombre manquant dans une liste de nombres. ..."</p>
                <a href="../Fonctions/explications_fonctions.html">Read More</a>
            </div>
        </div>
    </div>

    <!--Cube-->
    <div class="cube1-container1">
        <div class="cube1">
            <div class="top1"></div>
            <div>
                <span style="--i:0"></span>
                <span style="--i:1"></span>
                <span style="--i:2"></span>
                <span style="--i:3"></span>
            </div>
        </div>
    </div>

    <div class="cube2-container2">
        <div class="cube2">
            <div class="top2"></div>
            <div>
                <span style="--i:0"></span>
                <span style="--i:1"></span>
                <span style="--i:2"></span>
                <span style="--i:3"></span>
            </div>
        </div>
    </div>

    <div class="cube3-container3">
        <div class="cube3">
            <div class="top3"></div>
            <div>
                <span style="--i:0"></span>
                <span style="--i:1"></span>
                <span style="--i:2"></span>
                <span style="--i:3"></span>
            </div>
        </div>
    </div>

    <div class="cube4-container4">
        <div class="cube4">
            <div class="top4"></div>
            <div>
                <span style="--i:0"></span>
                <span style="--i:1"></span>
                <span style="--i:2"></span>
                <span style="--i:3"></span>
            </div>
        </div>
    </div>

    <!--Explication des fonctions-->
    <h3 id="margin">Couleur</h3>
    <!--Explication de Couleur-->
    <div class="container_explications_fonctions">
        <div class="box">
            <span></span>
            <div class="content_explications_fonctions">
                <h2>Explication de la fonction</h2>
                <p>
                    La première fonction que nous avons créée utilise des listes pour stocker les couleurs en français et en anglais,
                    ce qui permet d'accéder directement aux positions des éléments pour les comparaisons.
                    Elle présente une complexité temporelle d'environ 1.83e-5 secondes.
                    <br><br>
                    En revanche, la deuxième fonction que nous avons créée utilise un dictionnaire inversé pour stocker les couleurs et
                    présente une complexité temporelle d'environ 4.41e-5 secondes.
                    <br><br>
                    Nous avons constaté que les dictionnaires impliquent des recherches plus coûteuses pour trouver les correspondances entre
                    les clés et les valeurs par rapport aux listes.
                    Par conséquent, nous avons choisi de conserver la première fonction en raison de sa complexité temporelle plus faible,
                    ce qui permet une exécution plus rapide.

                </p>
            </div>
        </div>

        <div class="box">
            <span></span>
            <div class="content_explications_fonctions">
                <h2>Code PYTHON</h2>
                <pre>
def couleur(donnees: dict) -> str or None:
    """
    Vérifie si les couleurs dans les défis sont valides en comparant avec des listes de couleurs en français et en anglais.
    Args:donnees (dict): Un dictionnaire contenant couleurs -> "colors".
    :return: la clef du dictionnaire colors correspondant à la même couleur que sa clef, sinon None.
    """
    couleur_fr = ("argent", "beige", "blanc", "bleu", "corail", "indigo", "jaune", "lavande", "magenta", "marron", "mauve", "noir", "olive", "or", "orange", "orchidée", "rose", "rouge", "saumon", "vert")
    couleur_en = ("silver", "beige", "white", "blue", "coral", "indigo", "yellow", "lavender", "magenta", "brown", "mauve", "black", "olive", "gold", "orange", "orchid", "pink", "red", "salmon", "green")
    
    # On parcourt la liste des couleurs
    for cle,valeur in donnees["colors"].items():
        if cle == valeur:
            return cle
        elif cle in couleur_fr:
            # On sauvegarde la position de "cle" ce trouvant dans "couleur_fr"
            position_couleur = couleur_fr.index(cle)
            # On regarde si la valeur ce trouve à la même position que la "cle" dans "couleur_en"
            if (valeur in couleur_en) and (valeur == couleur_en[position_couleur]):
                return cle
        else:
            position_couleur = couleur_en.index(cle)
            if (valeur in couleur_fr) and (valeur == couleur_fr[position_couleur]):
                return cle
    
    return False
                </pre>
            </div>
        </div>
    </div>

    <h3>Réflexion</h3>
    <!--Explication de reflexion-->
    <div class="container_explications_fonctions">
        <div class="box">
            <span></span>
            <div class="content_explications_fonctions">
                <h2>Explication de la fonction</h2>
                <p>
                    La première fonction que l'on a créee utilise une approche récursive pour parcourir une carte en suivant un faisceau lumineux.
                    Sa complexité temporelle dépend de la taille de la carte et du chemin parcouru.
                    Dans le pire des cas, si le faisceau lumineux traverse toute la carte sans rencontrer d'arrêt,
                    la complexité peut être linéaire par rapport à la taille de la carte.
                    <br><br>
                    La seconde fonction applique un raisonnement sur un dessin en utilisant différentes méthodes pour vérifier s'il y a une solution possible.
                    Elle effectue des opérations de décalage, inversion et recherche d'égalité.
                    La complexité de cette fonction dépend de la taille du dessin et du nombre de pièces à comparer.
                    Dans le pire des cas, si toutes les opérations doivent être effectuées, la complexité peut être quadratique.
                    <br><br>
                    Nous avons choisi la première fonction au lieu de la seconde car sa complexité est généralement plus basse,
                    en particulier lorsque la carte est grande et que le parcours est court.
                    La récursivité permet d'explorer rapidement le chemin du faisceau lumineux jusqu'à ce qu'une condition d'arrêt soit rencontrée.
                </p>
            </div>
        </div>

        <div class="box">
            <span></span>
            <div class="content_explications_fonctions">
                <h2>Code PYTHON</h2>
                    <pre>
def reflexion(donnees: dict) -> int:
    """
    Parcours la map en cherchant où va la lumière de la lampe
    Args:donnees (dict): Un dictionnaire contenant la map.
    :return: un entier
    """
    return parcours_lampe_torche(donnees, "haut", 5, 2)


def parcours_lampe_torche(donnees: dict, direction: str, ligne: str, colonne: str) -> int:
    """
    Parcours la map en suivant le faisceau lumineux
    :param:
        donnees : "dict"
        direction : "string"
        ligne : "int"
        colonne : "int"
    :return: un entier (int)
    """
    if type(donnees["map"][ligne][colonne]) == int:
        return int(donnees["map"][ligne][colonne])

    direction = si_miroir(donnees, direction, ligne, colonne)

    if direction == "bas":
        return parcours_lampe_torche(donnees, direction, ligne+1, colonne)
    elif direction == "haut":
        return parcours_lampe_torche(donnees, direction, ligne-1, colonne)
    elif direction == "droite":
        return parcours_lampe_torche(donnees, direction, ligne, colonne+1)
    else:
        return parcours_lampe_torche(donnees, direction, ligne, colonne-1)


def si_miroir(donnees: dict, direction: str, ligne: str, colonne: str):
    """
    Indique si sur les coordonnées pris en paramètres, il y a un miroir
    :param:
        donnees : "dict"
        direction : "string"
        ligne : "int"
        colonne : "int"
    :return: la direction (string)
    """
    if donnees["map"][ligne][colonne] == "/":
        if direction == "haut":
            return "droite"
        elif direction == "bas":
            return "gauche"
        elif direction == "droite":
            return "haut"
        elif direction == "gauche":
            return "bas"
    elif donnees["map"][ligne][colonne] == "\\":
        if direction == "haut":
            return "gauche"
        elif direction == "bas":
            return "droite"
        elif direction == "droite":
            return "bas"
        elif direction == "gauche":
            return "haut"
        
    return direction                    
</pre>
            </div>
        </div>
    </div>

    <h3>Calcul</h3>
    <!--Explication de calcul-->
    <div class="container_explications_fonctions">
        <div class="box">
            <span></span>
            <div class="content_explications_fonctions">
                <h2>Explication de la fonction</h2>
                <p>
                    La première fonction qu'on a créer utilise une approche récursive pour trouver toutes les combinaisons de nombres
                    dans une liste qui s'additionnent pour obtenir un nombre cible. Elle convertit ensuite ces combinaisons en chaînes
                    de caractères avec des "+" comme séparateurs. Elle présente une complexité temporelle d'environ 1.10e-05 secondes.
                    <br><br>
                    La seconde fonction utilise une boucle pour générer toutes les combinaisons possibles à l'aide de la fonction combinations du
                    <a href="https://docs.python.org/fr/3/library/itertools.html">module itertools</a>.
                    Elle vérifie ensuite si la somme de chaque combinaison est égale au nombre cible.
                    Si une combinaison satisfait cette condition, elle est convertie en une chaîne de caractères avec des "+" comme séparateurs.
                    La complexité temporelle moyenne de cette fonction est d'environ 3.89e-06 secondes.
                    <br><br>
                    La seconde fonction, a donc été privilégiée en raison de sa performance en termes de temps d'exécution.
                    Elle fournit une solution efficace pour trouver les combinaisons de nombres qui s'additionnent pour obtenir le nombre cible.
                </p>
            </div>
        </div>

        <div class="box">
            <span></span>
            <div class="content_explications_fonctions">
                <h2>Code PYTHON</h2>
                    <pre>
from itertools import combinations

def calcul(donnees: dict) -> str or None:
    """
    Fonction qui recherche une combinaison de nombres dans la liste 'numbers' dont la somme est égale à 'result'.
    Args:donnees (dict): Un dictionnaire contenant les clés 'result' et 'numbers'.
    Returns: str or None: Une chaîne de caractères représentant la combinaison trouvée, si une combinaison satisfaisant la condition est trouvée. Sinon, renvoie None.
    """
    result = donnees["result"]
    numbers = donnees["numbers"]
    for i in range(1, len(numbers) + 1):
        for combo in combinations(numbers, i):
            if sum(combo) == result:
                combo_str = "+".join(str(num) for num in combo)
                return combo_str
            
    return None                          
                </pre>
            </div>
        </div>
    </div>

    <h3>Fréquence</h3>
    <!--Explication de frequence-->
    <div class="container_explications_fonctions">
        <div class="box">
            <span></span>
            <div class="content_explications_fonctions">
                <h2>Explication de la fonction</h2>
                <p>
                    La 1ère fonction que l'on a créer utilise un dictionnaire pour stocker les occurrences de chaque mot.
                    Elle itère sur chaque mot de la liste de mots et met à jour le dictionnaire des occurrences.
                    Ensuite, elle recherche le mot ayant le nombre d'occurrences le plus faible en parcourant le dictionnaire.
                    <br><br>
                    La seconde fonction utilise le <a href="https://docs.python.org/fr/3/library/collections.html">module Counter</a> pour compter les occurrences de chaque mot dans la liste de mots fournie.
                    Elle retourne ensuite le mot le moins représenté en utilisant la fonction min avec la clé word_count.get.
                    <br><br>
                    La seconde fonction a été choisie en raison de son utilisation du module Counter qui simplifie le comptage des occurrences des mots.
                    Cela permet une implémentation plus concise et claire de la fonction.
                    De plus, l'utilisation de la fonction min avec la clé word_count.get permet de trouver directement le mot le moins représenté.
                    <br><br>
                    En termes de performance, la seconde fonction a une complexité temporelle d'environ 1.01e-04 secondes,
                    tandis que la 1ère fonction a une complexité temporelle d'environ 1.91e-04 secondes.
                    La seconde fonction est légèrement plus efficace en raison de l'utilisation du module Counter,
                    qui est optimisé pour le comptage des occurrences.
                    <br><br>
                    En conclusion, la seconde fonction a été choisie en raison de son implémentation plus concise, 
                    claire et efficace grâce à l'utilisation du <a href="https://docs.python.org/fr/3/library/collections.html">module Counter</a>.
                    Elle offre une solution directe et optimisée pour trouver le mot le moins représenté dans la liste de mots.
                </p>
            </div>
        </div>

        <div class="box">
            <span></span>
            <div class="content_explications_fonctions">
                <h2>Code PYTHON</h2>
                    <pre>
from collections import Counter

def frequence(donnees: dict) -> str:
    """
    :param:
        donnees : "dict"
    :return: Le mot le moins représenté (str)
    """
    word_count = Counter()
    for ligne in donnees["words"]:
        word_count.update(ligne)
    
    return min(word_count, key=word_count.get)
                </pre>
            </div>
        </div>
    </div>

    <h3>Manquant</h3>
    <!--Explication de manquant-->
    <div class="container_explications_fonctions">
        <div class="box">
            <span></span>
            <div class="content_explications_fonctions">
                <h2>Explication de la fonction</h2>
                <p>
                    Les deux fonctions que l'on a créer cherchent toutes les deux le premier nombre manquant dans une liste de nombres.
                    Elles utilisent une approche similaire en séparant les nombres en deux listes en fonction de leur couleur.
                    Les deux fonctions trient ensuite les listes de nombres avant de chercher le premier nombre manquant.
                    <br><br>
                    La différence entre les deux fonctions réside principalement dans la façon dont elles traitent les nombres.
                    <br><br>
                    La première stocke les nombres en tant que chaînes de caractères dans les listes list_numbers_color1 et list_numbers_color2.
                    Elle effectue ensuite une conversion de ces chaînes de caractères en entiers lors de la vérification du premier nombre manquant.
                    Cela introduit une surcharge de conversion de types à chaque itération de la boucle.
                    <br><br>
                    En revanche, la deuxième stocke directement les nombres en tant qu'entiers dans les listes list_numbers_color1 et list_numbers_color2,
                    évitant ainsi la conversion de types lors de la vérification du premier nombre manquant.
                    <br><br>
                    En termes de complexité, les deux fonctions effectuent des opérations similaires.
                    La complexité principale réside dans le tri des listes de nombres, qui a une complexité de O(n log n),
                    où n est la taille des listes. Ensuite, les boucles qui recherchent le premier nombre manquant ont une complexité linéaire O(n).
                    <br><br>
                    En raison de la différence de traitement des nombres et de la conversion de types évitée dans la seconde fonction,
                    celle-ci est généralement plus efficace en termes de rapidité et de performances.
                </p>
            </div>
        </div>

        <div class="box">
            <span></span>
            <div class="content_explications_fonctions">
                <h2>Code PYTHON</h2>
                    <pre>
def manquant(donnees: dict) -> int or None:
    """
    Fonction permettant de trouver le premier nombre manquant dans une liste de nombres.
    :param:
        donnees : "dict"
    :return: int: Le premier nombre manquant dans la liste de nombres.
    """
    list_numbers_color1 = []  # Utilisation d'un ensemble pour stocker les nombres de couleur 1
    list_numbers_color2 = []  # Utilisation d'un ensemble pour stocker les nombres de couleur 2

    # Permet de récupérer une couleur disponible et de les mettre dans "list_color"
    couleur = donnees["numbers"][0][-1]

    # Permet de récupérer les nombres et de les mettre dans leur ensemble respectif
    for color in donnees["numbers"]:
        if color[-1] == couleur:
            list_numbers_color1.append(int(color[:-1]))
        else:
            list_numbers_color2.append(int(color[:-1]))

    list_numbers_color1 = sorted(list_numbers_color1, key=int)
    list_numbers_color2 = sorted(list_numbers_color2, key=int)

    # Trouver le premier nombre manquant dans list_numbers_color1
    for number in range(len(list_numbers_color1)-1):
        if list_numbers_color1[number+1] != list_numbers_color1[number]+1:
            return int(list_numbers_color1[number]+1)

    # Trouver le premier nombre manquant dans list_numbers_color2
    for number in range(len(list_numbers_color2)-1):
        if list_numbers_color2[number+1] != list_numbers_color2[number]+1:
            return int(list_numbers_color2[number]+1)

    return None                    
                </pre>
            </div>
        </div>
    </div>

    <h3>Labyrinthe</h3>
    <!--Explication de labyrinthe-->
    <div class="container_explications_fonctions">
        <div class="box">
            <span></span>
            <div class="content_explications_fonctions">
                <h2>Explication de la fonction</h2>
                <p>
                    La première fonction que l'on a créée utilise une file de priorité <a href="https://docs.python.org/fr/3/library/heapq.html?highlight=file%20priorit%C3%A9">(heap)</a> pour implémenter l'algorithme de recherche
                    <a href="https://fr.wikipedia.org/wiki/Algorithme_A*">A*</a> dans un labyrinthe.
                    Sa complexité temporelle dépend de la taille du labyrinthe et du nombre de cases visitées.
                    Dans le pire des cas, si toutes les cases du labyrinthe doivent être visitées, la complexité peut être exponentielle.
                    <br><br>
                    La seconde fonction utilise également une file de priorité <a href="https://docs.python.org/fr/3/library/heapq.html?highlight=file%20priorit%C3%A9">(heap)</a> et implémente également l'algorithme
                    <a href="https://upload.wikimedia.org/wikipedia/commons/5/5d/Astar_progress_animation.gif">A*</a> pour la recherche dans un labyrinthe.
                    Sa complexité temporelle est similaire à celle de la première fonction, dépendant de la taille du labyrinthe et du nombre de cases visitées.
                    <br><br>
                    La différence de performance entre les deux fonctions n'est pas significative car les deux fonctions ont une complexité
                    temporelle similaire et réalisent la même tâche.
                    Cependant, en mesurant la moyenne du temps d'exécution des deux fonctions sur différentes tailles de map,
                    la première fonction a un temps d'exécution moyen de 4.52e-04 secondes, tandis que la seconde fonction a un temps d'exécution moyen de 4.50e-04 secondes.
                    <br><br>
                    Par conséquent, la seconde fonction a été choisie.
                </p>
            </div>
        </div>

        <div class="box">
            <span></span>
            <div class="content_explications_fonctions">
                <h2>Code PYTHON</h2>
                    <pre>
import math
import heapq

def labyrinthe(donnees: dict) -> int or None:
    """
    Cherche la sortie du labyrinthe
    :param:
        donnees : "dict"
    :return: un entier étant l'arrivée    
    """
    labyrinth = donnees["map"]
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Haut, Bas, Gauche, Droite
    start_pos = None
    goal_pos = [("1", (0, 0)), ("2", (0, len(labyrinth[0])-1)), ("3", (len(labyrinth)-1, len(labyrinth[0])-1)), ("4", (len(labyrinth)-1, 0))]  # Positions des sorties

    for i in range(len(labyrinth)):
        for j in range(len(labyrinth[i])):
            if labyrinth[i][j] == "D":
                start_pos = (i, j)

    queue = []
    visited = set()
    heapq.heappush(queue, (0, start_pos, []))  # File d'attente avec la priorité basée sur la distance

    while queue:
        _, current_pos, path = heapq.heappop(queue)

        if current_pos in [pos for _, pos in goal_pos]:
            goal = [key for key, value in goal_pos if value == current_pos][0]
            return int(goal)

        visited.add(current_pos)

        for direction in directions:
            new_pos:tuple = (current_pos[0] + direction[0], current_pos[1] + direction[1])

            if is_valid_position(new_pos, labyrinth) and new_pos not in visited:
                new_path = path + [current_pos]
                g_score = len(new_path)
                h_score = heuristic(new_pos, goal_pos)
                f_score = g_score + h_score
                heapq.heappush(queue, (f_score, new_pos, new_path))
                visited.add(new_pos)

    return None


def is_valid_position(position: tuple, labyrinth: list) -> True or False:
    """
    Vérifie si une position donnée est valide dans le labyrinthe.

    Paramètres :
        - position : Un tuple représentant la position à vérifier, avec les coordonnées (x, y).
        - labyrinth : Une liste de listes représentant le labyrinthe.

    Retour :
        - True si la position est valide et ne correspond pas à un mur ('X') dans le labyrinthe.
        - False sinon.
    """
    x, y = position
    if len(labyrinth) > x >= 0 and len(labyrinth[0]) > y >= 0 and labyrinth[x][y] != "X":
        return True
    return False


def heuristic(position, goal_pos) -> int:
    """
    Calcule l'heuristique (estimation) de distance entre une position donnée et une ou plusieurs positions buts.

    Paramètres :
        - position : Un tuple représentant la position de départ, avec les coordonnées (x, y).
        - goal_pos : Une liste de tuples représentant les positions buts, avec les coordonnées (x, y).

    Retour :
        - Un entier représentant la distance heuristique minimale entre la position de départ et une position but.
    """
    x1, y1 = position
    min_distance = math.inf

    for _, (x2, y2) in goal_pos:
        distance = abs(x1 - x2) + abs(y1 - y2)
        min_distance = min(min_distance, distance)

    return min_distance
                </pre>
            </div>
        </div>
    </div>

    <h3>Doublon</h3>
    <!--Explication de doublon-->
    <div class="container_explications_fonctions">
        <div class="box">
            <span></span>
            <div class="content_explications_fonctions">
                <h2>Explication de la fonction</h2>
                <p>
                    La première fonction utilise plusieurs étapes, notamment la création de plusieurs listes pour stocker les mots,
                    la suppression des répétitions, et l'utilisation d'un dictionnaire pour compter les occurrences de chaque mot.
                    Elle vérifie également s'il existe un mot avec une valeur de compteur égale à 2 pour trouver un mot en double.
                    De plus elle présente une complexité temporelle d'environ 5.04e-04 secondes.
                    <br><br>
                    La seconde fonction utilise un dictionnaire pour compter le nombre d'occurrences de chaque mot dans la liste de mots fournie.
                    Elle vérifie ensuite s'il existe un mot avec une valeur de compteur égale à 2, indiquant ainsi un mot en double.
                    Elle présente une complexité temporelle d'environ 2.09e-04 secondes.
                    <br><br>
                    La seconde fonction a été choisie en raison de son implémentation plus concise, claire et efficace. 
                    Elle utilise simplement un dictionnaire pour effectuer le comptage des occurrences de chaque mot, évitant ainsi des
                    itérations supplémentaires et des traitements inutiles. En revanche, la première fonction nécessite des étapes supplémentaires
                    telles que la création de plusieurs listes et une itération supplémentaire pour obtenir le résultat souhaité.
                    <br><br>
                    En conclusion, la seconde fonction a été privilégiée en raison de sa simplicité, de sa clarté et de son efficacité,
                    offrant ainsi une solution plus directe au problème donné.
                </p>
            </div>
        </div>

        <div class="box">
            <span></span>
            <div class="content_explications_fonctions">
                <h2>Code PYTHON</h2>
                    <pre>
def doublon(donnees: dict) -> str or None:
    """
    Recherche un mot en double dans la liste de mots fournie.
    :param:
        donnees : "dict"
    :return: (str) Le mot en double s'il existe, sinon None.
    """
    word_count = {}
    for ligne in donnees["words"]:
        for word in ligne:
            if word in word_count:
                word_count[word] += 1
            else:
                word_count[word] = 1

    # Retourne le mot en double
    for cle, valeur in word_count.items():
        if valeur == 2:
            return str(cle)
        
    return None                    
                </pre>
            </div>
        </div>
    </div>

    <h3>Raisonnement</h3>
    <!--Explication de raisonnement-->
    <div class="container_explications_fonctions">
        <div class="box">
            <span></span>
            <div class="content_explications_fonctions">
                <h2>Explication de la fonction</h2>
                <p>
                    Les deux fonctions que l'on a créer, effectuent essentiellement les mêmes opérations pour résoudre un problème de dessin.
                    <br><br>
                    La seconde utilise des listes en compréhension pour filtrer et décaler les lignes du dessin, ce qui permet d'éviter des boucles supplémentaires.
                    De plus, elle utilise des indices inversés pour retourner horizontalement les lignes du dessin, ce qui réduit la complexité de cette opération.
                    <br><br>
                    D'autre part, la première utilise des boucles for traditionnelles pour filtrer et décaler les lignes,
                    ce qui entraîne une complexité légèrement supérieure.
                    Elle utilise également des boucles for pour retourner horizontalement les lignes, ce qui est légèrement moins efficace que l'approche avec des indices inversés.
                    <br><br>
                    La première présente une complexité temporelle d'environ 2.19e-04 secondes.
                    Tandis ce que la seconde présente une complexité temporelle d'environ 2.16e-04 secondes.
                    <br><br>
                    En résumé, nous avons choisi la seconde car elle présente une complexité inférieure et utilise des méthodes plus efficaces
                    pour réaliser les mêmes opérations que la première.
                </p>
            </div>
        </div>

        <div class="box">
            <span></span>
            <div class="content_explications_fonctions">
                <h2>Code PYTHON</h2>
                <pre>
def raisonnement(donnees: dict) -> str or None:
    """
    Applique un raisonnement sur le dessin en utilisant différentes méthodes pour vérifier s'il y a une solution possible.
    :param:
        donnees : "dict"
    :return: Le nom de la solution trouvée, sinon None.
    """
    drawing = donnees["drawing"]
    pieces = donnees["pieces"]

    # On regarde si il y a possibilité d'enlever des colonnes à droite du dessin
    decalage = decalage_raisonnement(drawing)

    # On décale chaque ligne du dessin par "decalage"
    new_drawing = [ligne[decalage:] for ligne in drawing if "" in ligne]

    # On regarde si il y a possibilité d'enlever des colonnes à gauche du dessin mais pour cela on va inverser chaque ligne du dessin
    new_drawing = retourne_raisonnement(new_drawing)
    # On regarde si il y a possibilité d'enlever des colonnes à droite du dessin
    decalage_new_drawing = decalage_raisonnement(new_drawing)

    # On décale chaque ligne du dessin par "decalage_new_drawing"
    finish_drawing = [ligne[decalage_new_drawing:] for ligne in new_drawing if "" in ligne]

    # On remet le dessin à l'endroit
    finish_drawing = retourne_raisonnement(finish_drawing)
    # On inverse le vide ("") avec les murs ("X")
    finish_drawing = inversion_raisonnement(finish_drawing)
    # On regarde si une solution est possible
    for nom, map in pieces.items():
        if finish_drawing == map:
            return str(nom)

    return None


def decalage_raisonnement(drawing: list) -> int:
    """
    Recherche le décalage possible le plus à gauche du dessin en vérifiant chaque ligne.
    :param drawing: (list) Le dessin représenté sous forme de liste de listes.
    :return: (int) Le décalage possible le plus à gauche du dessin.
    """
    possibilite_decalage = []
    arrete_for = False
    # On parcourt chaque ligne de "drawing"
    for ligne in drawing:
        decalage = 0
        compteur = 0 # Pour savoir si on est au début de la ligne
        # On parcourt chaque symbole surla ligne
        for symbole in ligne:
            # Si le symbole est un trou et qu'il se trouve au début de la ligne
            if (symbole == "") and (compteur == 0):
                decalage = 0
                return decalage
            elif symbole == "X":
                decalage += 1
            # Sinon on arrête les boucles "for"
            else:
                possibilite_decalage.append(decalage)
                break
            
            compteur += 1

        if arrete_for:
            break

    return min(possibilite_decalage)


def retourne_raisonnement(drawing: list) -> list:
    """
    Retourne horizontalement chaque ligne du dessin.
    :param drawing: (list) Le dessin représenté sous forme de liste de listes.
    :return: (list) Le dessin modifié avec chaque ligne retournée horizontalement.
    """
    new_drawing = []
    for ligne in drawing:
        new_drawing.append(ligne[::-1])
    return new_drawing


def inversion_raisonnement(drawing: list) -> list:
    """
    Inverse les cases vides ("") avec les cases pleines ("X") dans le dessin.
    :param drawing: (list) Le dessin représenté sous forme de liste de listes.
    :return: (list) Le dessin modifié avec les cases inversées.
    """
    for ligne in range(len(drawing)):
        for colonne in range(len(drawing[ligne])):
            if drawing[ligne][colonne] == "":
                drawing[ligne][colonne] = "X"
            else:
                drawing[ligne][colonne] = ""
    return drawing                
                </pre>
            </div>
        </div>
    </div>

    <footer>
        <p>
            <a href="https://validator.w3.org/nu/?doc=https%3A%2F%2Fbrunbrun24.github.io%2FCortex-Challenge%2FHtml%2FFonctions%2Fexplications_fonctions.html" target="_blank">
                <img src="https://raw.githubusercontent.com/bradleytaunt/html5-valid-badge/68b012b5c19b26f75d9bee2409420c916b2d451a/html5-validator-badge.svg" alt="HTML5 Valide !">
            </a>
        </p>
        <p>
            <a href="https://jigsaw.w3.org/css-validator/validator?uri=https%3A%2F%2Fbrunbrun24.github.io%2FCortex-Challenge%2FHtml%2FFonctions%2Fexplications_fonctions.html&profile=css3svg&usermedium=all&warning=1&vextwarning=&lang=fr" target="_blank">
                <img src="https://jigsaw.w3.org/css-validator/images/vcss" alt="CSS Valide !">
            </a>
        </p>
    </footer>
    
</body>
</html>