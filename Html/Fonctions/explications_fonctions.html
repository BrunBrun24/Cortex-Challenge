<!DOCTYPE html>
<html lang="fr">
<head>
    <title>Fonctions</title>
    <link rel="stylesheet" type="text/css" href="../style_all.css">
    <link rel="stylesheet" type="text/css" href="style.css">
    <link rel="stylesheet" type="text/css" href="../menues.css">
    <link rel="stylesheet" type="text/css" href="../cube.css">
    <link rel="stylesheet" type="text/css" href="menues_explications_fonctions.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

    <h1>Explications des fonctions utilisées</h1>

    <div class="container">
        <div class="box">
            <span></span>
            <div class="content1">
                <h2>Accueil</h2>
                <a href="../../index.html">Read More</a>
            </div>
        </div>
    
        <div class="box">
            <span></span>
            <div class="content">
                <h2>Groupe</h2>
                <p>"Lors de la réalisation de notre projet à deux, nous avons adopté une approche organisée pour travailler de manière efficace malgré la distance. Nous avons utilisé ..."</p>
                <a href="../Groupe/groupe.html">Read More</a>
            </div>
        </div>
    
        <div class="box">
            <span></span>
            <div class="content">
                <h2>Sujet</h2>
                <p>"Le jeu Cortex risque de vous brûler les méninges! Ce jeu de réflexion et de rapidité va vous lancer des défis à la fois ludiques et éducatifs autour de 8 épreuves ..."</p>
                <a href="../Sujet/sujet.html">Read More</a>
            </div>
        </div>

        <div class="box">
            <span></span>
            <div class="content">
                <h2>Fonctions</h2>
                <p>"Cette fonction est intéressante d'un point de vue complexité car elle utilise une double boucle for pour comparer chaque couleur dans la liste avec les couleurs dans ..."</p>
                <a href="../Fonctions/explications_fonctions.html">Read More</a>
            </div>
        </div>
    </div>

    <!--Cube-->
    <div class="cube1">
        <div class="top1"></div>
        <div>
            <span style="--i:0";></span>
            <span style="--i:1";></span>
            <span style="--i:2";></span>
            <span style="--i:3";></span>
        </div>
    </div>
    <div class="cube2">
        <div class="top2"></div>
        <div>
            <span style="--i:0";></span>
            <span style="--i:1";></span>
            <span style="--i:2";></span>
            <span style="--i:3";></span>
        </div>
    </div>
    <div class="cube3">
        <div class="top3"></div>
        <div>
            <span style="--i:0";></span>
            <span style="--i:1";></span>
            <span style="--i:2";></span>
            <span style="--i:3";></span>
        </div>
    </div>
    <div class="cube4">
        <div class="top4"></div>
        <div>
            <span style="--i:0";></span>
            <span style="--i:1";></span>
            <span style="--i:2";></span>
            <span style="--i:3";></span>
        </div>
    </div>

    <!--Explication des fonctions-->
    <h3>Couleur</h3>
    <!--Explication de Couleur-->
    <div class="container_explications_fonctions">
        <div class="box">
            <span></span>
            <div class="content_explications_fonctions">
                <h2>Explication de la fonction</h2>
                <p>
                    Cette fonction est intéressante d'un point de vue complexité car elle utilise une double boucle for pour comparer chaque couleur dans la liste
                    avec les couleurs dans le dictionnaire de référence. La complexité de cette fonction est donc de O(n*m), où n est la longueur de la liste de
                    couleurs dans donnee et m est la taille du dictionnaire de référence.
                    <br><br>
                    Cependant, la complexité réelle de la fonction dépendra de la taille du dictionnaire dict. Si la taille de ce dictionnaire est petite, la
                    complexité de la fonction sera également petite. Si la taille du dictionnaire dict augmente, la complexité de la fonction augmentera également.
                </p>
            </div>
        </div>

        <div class="box">
            <span></span>
            <div class="content_explications_fonctions">
                <h2>Code PYTHON</h2>
                <pre>
def couleur(defis):
    # Création d'un dictionnaire inversé pour les couleurs en français
    dict = {"silver": "argent",
            "beige": "beige",
            "white": "blanc",
            "blue": "bleu",
            "coral": "corail",
            "indigo": "indigo",
            "yellow": "jaune",
            "lavender": "lavande",
            "magenta": "magenta",
            "brown": "marron",
            "mauve": "mauve",
            "black": "noir",
            "olive": "olive",
            "gold": "or",
            "orange": "orange",
            "orchid": "orchidée",
            "pink": "rose",
            "red": "rouge",
            "salmon": "saumon",
            "green": "vert"}

    for cle, valeur in defis["colors"].items():
        for c, v in dict.items():
            if cle == valeur:
                return cle
            elif (cle == c) and (valeur == v):
                return cle
            elif (cle == v) and (valeur == c):
                return cle
    return False
                </pre>
            </div>
        </div>
    </div>

    <h3>Reflexion</h3>
    <!--Explication de reflexion-->
    <div class="container_explications_fonctions">
        <div class="box">
            <span></span>
            <div class="content_explications_fonctions">
                <h2>Explication de la fonction</h2>
                <p>
                    La fonction reflexion prend en entrée un dictionnaire donnee représentant une map de jeu et renvoie la valeur de la case atteinte par la lumière
                    provenant de la lampe "L", en suivant les règles du jeu.
                    La fonction commence par chercher la position de la lampe "L" dans la map en parcourant chaque ligne et colonne de la map jusqu'à trouver la lampe.
                    Si la lampe est trouvée, la fonction appelle la fonction deplacement_lumiere en passant les coordonnées de la lampe et la direction dans laquelle elle pointe.
                    <br><br>
                    La fonction deplacement_lumiere utilise une boucle while pour déplacer la lumière dans la direction donnée, en vérifiant si la case actuelle est
                    un entier. Si la case est un entier, la fonction renvoie la valeur de cette case. Sinon, la fonction appelle la fonction verifier_obstacle pour
                    obtenir la direction à suivre en fonction de la direction actuelle et de l'obstacle présent dans la case. Ensuite, les coordonnées de la lumière
                    sont mises à jour en fonction de la direction obtenue.
                    <br><br>
                    La fonction verifier_obstacle prend en entrée la position actuelle de la lumière et sa direction, vérifie si la case contient un obstacle "/" ou
                    "", et renvoie la nouvelle direction en fonction de l'obstacle. Elle utilise un dictionnaire de correspondance pour déterminer la nouvelle direction.
                    <br><br>
                    Du point de vue de la complexité, la fonction reflexion parcourt chaque ligne et colonne de la map, ce qui prend un temps proportionnel au nombre 
                    total de cases dans la map. La fonction deplacement_lumiere déplace la lumière dans la direction donnée jusqu'à ce qu'elle atteigne une case entière,
                    donc son temps d'exécution dépend du nombre de cases traversées par la lumière avant d'atteindre une case entière. Dans le pire des cas, si la lumière
                    suit un chemin en boucle infinie, la fonction peut ne jamais terminer. La fonction verifier_obstacle utilise un dictionnaire de correspondance pour
                    déterminer la nouvelle direction, ce qui a une complexité constante. Dans l'ensemble, la complexité de ces fonctions dépendent de la taille de la
                    map et du chemin emprunté par la lumière, ce qui peut varier considérablement d'une instance du jeu à l'autre.
                </p>
            </div>
        </div>

        <div class="box">
            <span></span>
            <div class="content_explications_fonctions">
                <h2>Code PYTHON</h2>
                    <pre>
def reflexion(defis):
    ligne_lampe = None
    colonne_lampe = None
    for i, ligne in enumerate(defis["map"]):
        if "L" in ligne:
            ligne_lampe = i
            colonne_lampe = ligne.index("L")
            if i == 0:
                direction_lampe = "bas"
            elif i == len(defis["map"])-1:
                direction_lampe = "haut"
            elif colonne_lampe == 0:
                direction_lampe = "droite"
            elif colonne_lampe == len(ligne)-1:
                direction_lampe = "gauche"
            
            return deplacement_lumiere(defis, ligne_lampe, colonne_lampe, direction_lampe)
    return False
      
    

def verifier_obstacle(defis, ligne, colonne, direction):
    obstacle = defis["map"][ligne][colonne]
    correspondances = {("/","haut"): "droite", ("/","bas"): "gauche", ("/","droite"): "haut", ("/","gauche"): "bas",
                    ("\\","haut"): "gauche", ("\\","bas"): "droite", ("\\","droite"): "bas", ("\\","gauche"): "haut"}
    return correspondances.get((obstacle, direction), direction)



def deplacement_lumiere(defis, ligne, colonne, direction):
    while True:
        # Vérifier si la case actuelle est un entier
        if isinstance(defis["map"][ligne][colonne], int):
            return defis["map"][ligne][colonne]
        else:
            # Appeler la fonction vérifier_obstacle pour obtenir la direction à suivre
            direction = verifier_obstacle(defis, ligne, colonne, direction)

            # Mettre à jour les coordonnées en fonction de la direction
            if direction == "bas":
                ligne += 1
            elif direction == "haut":
                ligne -= 1
            elif direction == "droite":
                colonne += 1
            elif direction == "gauche":
                colonne -= 1
                </pre>
            </div>
        </div>
    </div>

    <h3>Calcul</h3>
    <!--Explication de calcul-->
    <div class="container_explications_fonctions">
        <div class="box">
            <span></span>
            <div class="content_explications_fonctions">
                <h2>Explication de la fonction</h2>
                <p>
                    Cette fonction permet de trouver tous les ensembles de nombres dans la liste 'numbers' qui s'additionnent pour obtenir le résultat 'result'.
                    <br><br>
                    Elle utilise une approche récursive avec retour en arrière pour parcourir toutes les combinaisons possibles de nombres. La liste de nombres
                    est triée dans l'ordre croissant pour obtenir les combinaisons dans l'ordre croissant également. Les doublons sont ignorés pour éviter de
                    répéter les nombres dans la combinaison. Les nombres qui sont déjà dans la combinaison sont également ignorés.
                    <br><br>
                    La fonction auxiliaire 'trouver_combinaisons_recursif' est appelée initialement avec un total cible de 'result' et parcourt la liste de nombres
                    à partir de l'indice 'start'. Si la somme cible est atteinte, la liste de nombres est ajoutée aux résultats. Si la somme cible est dépassée, la
                    fonction retourne. Sinon, elle continue à parcourir la liste de nombres et à appeler récursivement la fonction avec le nouveau total cible.
                    <br><br>
                    Le résultat est ensuite trié et formaté en chaînes de caractères contenant les nombres séparés par des signes plus (+).
                    <br><br>
                    Du point de vue de la complexité, cette fonction a une complexité exponentielle O(2^n) dans le pire des cas, car elle parcourt toutes les
                    combinaisons possibles de nombres dans la liste. Cependant, elle utilise des techniques d'optimisation telles que le tri et l'ignorance des
                    doublons pour améliorer les performances.
                </p>
            </div>
        </div>

        <div class="box">
            <span></span>
            <div class="content_explications_fonctions">
                <h2>Code PYTHON</h2>
                    <pre>
def calcul(defis):
    result = defis["result"]
    numbers = defis["numbers"]
    res = []
    numbers.sort()  # Trie les nombres pour obtenir les combinaisons dans l'ordre croissant
    trouver_combinaisons_recursif(0, result, [], numbers, res)  # Appel initial de la fonction auxiliaire avec un total cible de 'result'

    output = []
    for solution in res:
        solution.sort()
        output.append('+'.join([str(x) for x in solution]))

    return output



def trouver_combinaisons_recursif(start, target, path, numbers, res):
    if target == 0:
        # Si la somme cible est atteinte, ajouter la liste de nombres dans les résultats
        res.append(path[:])
    elif target < 0:
        # Si la somme cible est dépassée, revenir en arrière
        return
    else:
        for i in range(start, len(numbers)):
            # Parcourir la liste de nombres à partir de l'indice 'start'
            if i > start and numbers[i] == numbers[i-1]:
                # Ignorer les doublons pour éviter de répéter les nombres dans la combinaison
                continue
            if numbers[i] not in path:
                # Ignorer les nombres qui sont déjà dans la combinaison
                path.append(numbers[i])
                trouver_combinaisons_recursif(i + 1, target - numbers[i], path, numbers, res)  # Appel récursif avec le nouveau total cible
                path.pop()  # Retour en arrière (trouver_combinaisons_recursif)
                </pre>
            </div>
        </div>
    </div>

    <h3>Frequence</h3>
    <!--Explication de frequence-->
    <div class="container_explications_fonctions">
        <div class="box">
            <span></span>
            <div class="content_explications_fonctions">
                <h2>Explication de la fonction</h2>
                <p>
                    La fonction "frequence" prend en entrée un dictionnaire "defis" contenant une liste de mots et retourne le mot le moins représenté dans cette liste.
                    <br><br>
                    Elle initialise un dictionnaire vide appelé "word_count" pour stocker le nombre d'occurrences de chaque mot. Ensuite, elle parcourt chaque ligne dans
                    la liste de mots du dictionnaire "defis" et pour chaque mot dans chaque ligne, elle met à jour le compte du mot dans le dictionnaire "word_count".
                    Si le mot existe déjà dans le dictionnaire, son compteur est augmenté de 1. Sinon, le mot est ajouté au dictionnaire avec un compteur initialisé à 1.
                    <br><br>
                    Enfin, la fonction utilise la méthode "min" avec la clé "word_count.get" pour trouver le mot ayant la valeur minimale dans le dictionnaire "word_count".
                    Ce mot est renvoyé en tant que résultat.
                    <br><br>
                    La complexité de cette fonction dépend du nombre total de mots dans la liste "defis['words']".
                    Supposons que cette liste contienne "n" mots au total. Dans le pire des cas, chaque mot sera unique, ce qui signifie que le dictionnaire "word_count"
                    aura "n" clés différentes. La mise à jour du dictionnaire nécessite une recherche de clé qui a une complexité moyenne de O(1) en utilisant une table
                    de hachage. Par conséquent, la boucle principale de la fonction a une complexité de O(n). Ensuite, la recherche du mot ayant la valeur minimale dans le
                    dictionnaire se fait en parcourant toutes les clés, ce qui a une complexité de O(n). En conclusion, la complexité totale de la fonction est de O(n), où
                    "n" est le nombre total de mots dans la liste "defis['words']".
                </p>
            </div>
        </div>

        <div class="box">
            <span></span>
            <div class="content_explications_fonctions">
                <h2>Code PYTHON</h2>
                    <pre>
def frequence(defis):
"""
:return: Le mot le moins représenté (str)
"""
word_count = {}
for ligne in defis["words"]:
    for word in ligne:
        if word in word_count:
            word_count[word] += 1
        else:
            word_count[word] = 1
    
return min(word_count, key=word_count.get)
                </pre>
            </div>
        </div>
    </div>

    <h3>Manquant</h3>
    <!--Explication de manquant-->
    <div class="container_explications_fonctions">
        <div class="box">
            <span></span>
            <div class="content_explications_fonctions">
                <h2>Explication de la fonction</h2>
                <p>
                    Cette fonction permet de trouver le premier nombre manquant dans une liste de nombres qui sont codés sous forme de chaînes de caractères.
                    <br><br>
                    Elle commence par séparer les nombres en fonction de leur couleur (identifiée par la dernière lettre de la chaîne), en les ajoutant à deux
                    ensembles distincts. Ensuite, elle trie ces ensembles dans l'ordre croissant. Enfin, elle parcourt chaque ensemble pour trouver le premier
                    nombre manquant, c'est-à-dire le premier nombre qui n'a pas un nombre suivant immédiat dans l'ensemble.
                    <br><br>
                    La complexité de cette fonction est de l'ordre O(nlogn) pour trier les ensembles de nombres, plus deux boucles for qui parcourent les ensembles,
                    chacune ayant une complexité de l'ordre de O(n). Par conséquent, la complexité totale de la fonction est de l'ordre de O(nlogn).
                </p>
            </div>
        </div>

        <div class="box">
            <span></span>
            <div class="content_explications_fonctions">
                <h2>Code PYTHON</h2>
                    <pre>
def manquant(donnees):
    list_color = [] # List des couleurs disponible
    list_numbers_color1 = []
    list_numbers_color2 = []
    # Permet de récupérer les couleurs disponible et de les mettre dans "list_color"
    for color in donnees["numbers"]:
        # On sait que l'initiale de la couleur est au dernier caractère
        if color[-1] not in list_color:
            list_color.append(color[-1])
    # Permet de récupérer les nombres et de les mettres dans leur list respective
    for color in donnees["numbers"]:
        if color[-1] == list_color[0]:
            list_numbers_color1.append(color[:-1])
        else:
            list_numbers_color2.append(color[:-1])

    # On trie les listes avec les nombres
    list_numbers_color1.sort()
    list_numbers_color2.sort()

    for number in range(len(list_numbers_color1)-1):
        n = list(map(int, list_numbers_color1))
        if n[number+1] != n[number]+1:
            return n[number]+1

    for number in range(len(list_numbers_color2)-1):
        n = list(map(int, list_numbers_color2))
        if n[number+1] != n[number]+1:
            return n[number]+1

    return False
                </pre>
            </div>
        </div>
    </div>

    <h3>Labyrinthe</h3>
    <!--Explication de labyrinthe-->
    <div class="container_explications_fonctions">
        <div class="box">
            <span></span>
            <div class="content_explications_fonctions">
                <h2>Explication de la fonction</h2>
                <p>
                    La fonction labyrinthe permet de parcourir un labyrinthe à partir de la position de départ et de renvoyer le numéro de la case atteinte selon les
                    règles spécifiées. Elle utilise une fonction auxiliaire appelée parcours_labyrinthe pour effectuer le parcours récursif du labyrinthe.
                    <br><br>
                    La fonction labyrinthe recherche d'abord les coordonnées de la case de départ dans le labyrinthe. Ensuite, elle initialise une file d'attente avec
                    une priorité basée sur la distance. Elle explore les cases adjacentes dans les directions haut, bas, gauche et droite, en évitant les cases marquées
                    comme obstacles ou déjà visitées. L'algorithme utilise une heuristique pour estimer la distance entre la position actuelle et les cases d'arrivée
                    possibles. Il continue d'explorer les cases jusqu'à ce qu'il atteigne l'une des cases d'arrivée, auquel cas il renvoie le numéro de cette case.
                    Si aucun chemin jusqu'à la sortie n'est trouvé, une erreur est levée.
                    <br><br>
                    La fonction is_valid_position vérifie si une position donnée est valide dans le labyrinthe, en tenant compte des limites du labyrinthe et des cases
                    marquées comme obstacles.
                    <br><br>
                    La fonction heuristic calcule une heuristique basée sur la distance de Manhattan entre une position donnée et les cases d'arrivée possibles.
                    Elle renvoie la plus petite distance parmi toutes les cases d'arrivée.
                    <br><br>
                    En utilisant les données fournies, la fonction labyrinthe est appelée avec les informations du labyrinthe. Le numéro de la case atteinte est
                    ensuite affiché.
                    <br><br>
                    La fonction utilise une approche récursive pour parcourir le labyrinthe, ce qui peut être efficace en termes de mémoire mais peut prendre du
                    temps pour des labyrinthes très grands ou complexes.
                </p>
            </div>
        </div>

        <div class="box">
            <span></span>
            <div class="content_explications_fonctions">
                <h2>Code PYTHON</h2>
                    <pre>
import heapq
import math

def labyrinthe(donnees):
    labyrinth = donnees["map"]
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # Haut, Bas, Gauche, Droite
    start_pos = None
    goal_pos = [("1", (0, 0)), ("2", (0, len(labyrinth[0])-1)), ("3", (len(labyrinth)-1, len(labyrinth[0])-1)), ("4", (len(labyrinth)-1, 0))]  # Positions des sorties
    for i in range(len(labyrinth)):
        for j in range(len(labyrinth[i])):
            if labyrinth[i][j] == "D":
                start_pos = (i, j)

    queue = [(0, start_pos, [])]  # File d'attente avec la priorité basée sur la distance
    visited = set()  # Positions déjà visitées

    while queue:
        _, current_pos, path = heapq.heappop(queue)
        if current_pos in [pos for _, pos in goal_pos]:
            goal = [key for key, value in goal_pos if value == current_pos][0]
            return goal

        visited.add(current_pos)

        for direction in directions:
            new_pos = (current_pos[0] + direction[0], current_pos[1] + direction[1])
            if is_valid_position(new_pos, labyrinth) and new_pos not in visited:
                new_path = path + [current_pos]
                g_score = len(new_path)
                h_score = heuristic(new_pos, goal_pos)
                f_score = g_score + h_score
                heapq.heappush(queue, (f_score, new_pos, new_path))
                visited.add(new_pos)

    raise ValueError("Aucun chemin trouvé jusqu'à la sortie.")



def is_valid_position(position, labyrinth):
    x, y = position
    if 0 <= x < len(labyrinth) and 0 <= y < len(labyrinth[0]) and labyrinth[x][y] != "X":
        return True
    return False



def heuristic(position, goal_pos):
    x1, y1 = position
    min_distance = math.inf

    for _, (x2, y2) in goal_pos:
        distance = abs(x1 - x2) + abs(y1 - y2)
        min_distance = min(min_distance, distance)

    return min_distance
                </pre>
            </div>
        </div>
    </div>

    <h3>Doublon</h3>
    <!--Explication de doublon-->
    <div class="container_explications_fonctions">
        <div class="box">
            <span></span>
            <div class="content_explications_fonctions">
                <h2>Explication de la fonction</h2>
                <p>
                    La fonction doublon prend en entrée un dictionnaire contenant une clé "words" qui est une liste de listes de mots et cherche un mot en double
                    dans cette liste.
                    <br><br>
                    Pour ce faire, elle utilise un dictionnaire word_count qui va compter le nombre d'occurrences de chaque mot dans la liste words. Si un mot est
                    déjà présent dans le dictionnaire, on incrémente son compteur, sinon on l'ajoute avec un compteur initialisé à 1.
                    <br><br>
                    Ensuite, la fonction parcourt le dictionnaire word_count et retourne le premier mot qui a été compté exactement deux fois, car cela signifie 
                    qu'il est présent en double dans la liste words.
                    <br><br>
                    Si aucun mot n'a été trouvé en double, la fonction retourne un message indiquant qu'il n'y a pas de mot en double.
                    <br><br>
                    D'un point de vue de la complexité, cette fonction est intéressante car elle utilise un dictionnaire pour compter le nombre d'occurrences de
                    chaque mot. La recherche et l'insertion dans un dictionnaire ont une complexité en moyenne O(1), ce qui signifie que la complexité totale de
                    cette fonction est de O(n), où n est le nombre total de mots dans la liste words. Cette complexité est optimale pour cette tâche, car il est
                    nécessaire de parcourir tous les mots au moins une fois pour déterminer s'il y en a un en double.
                </p>
            </div>
        </div>

        <div class="box">
            <span></span>
            <div class="content_explications_fonctions">
                <h2>Code PYTHON</h2>
                    <pre>
def doublon(defis):
    word_count = {}
    for ligne in defis["words"]:
        for word in ligne:
            if word in word_count:
                word_count[word] += 1
            else:
                word_count[word] = 1

    # Retourne le mot en double
    for cle, valeur in word_count.items():
        if valeur == 2:
            return cle
        
    return "Il n'y a pas de mot en double"
                </pre>
            </div>
        </div>
    </div>

    <h3>Raisonnement</h3>
    <!--Explication de raisonnement-->
    <div class="container_explications_fonctions">
        <div class="box">
            <span></span>
            <div class="content_explications_fonctions">
                <h2>Explication de la fonction</h2>
                <p>
                    Cette fonction, nommée raisonnement, prend en entrée une donnée représentant un dessin avec des murs (X) et des espaces vides
                    ("") ainsi qu'une liste de différentes pièces de puzzle. Elle applique un raisonnement sur le dessin en utilisant différentes
                    méthodes pour vérifier s'il y a une solution possible en cherchant quelle pièce de puzzle correspond au dessin.
                    <br><br>
                    Pour ce faire, la fonction commence par chercher s'il y a possibilité d'enlever des colonnes à droite du dessin et en enlevant
                    celles-ci si c'est le cas. Ensuite, elle cherche s'il y a possibilité d'enlever des colonnes à gauche du dessin en inversant
                    chaque ligne du dessin, en cherchant à nouveau si des colonnes peuvent être enlevées, puis en retournant à nouveau chaque ligne
                    pour revenir au dessin initial. Ensuite, elle inverse les cases vides ("") avec les cases pleines ("X") dans le dessin pour
                    permettre une comparaison plus facile avec les différentes pièces de puzzle. Finalement, elle compare le dessin modifié avec
                    chaque pièce de puzzle pour voir s'il y a une correspondance.
                    <br><br>
                    Cette fonction est intéressante d'un point de vue complexité car elle utilise des techniques efficaces pour réduire la taille
                    du dessin initial en enlevant des colonnes vides et en le retournant horizontalement pour enlever des colonnes supplémentaires.
                    Elle utilise également une technique d'inversion pour faciliter la comparaison entre le dessin modifié et les différentes pièces
                    de puzzle. Ces techniques permettent de réduire la taille du dessin initial et donc de diminuer la complexité de la comparaison
                    avec chaque pièce de puzzle, rendant l'algorithme plus efficace. Cependant, la complexité de cette fonction dépendra de la taille
                    du dessin initial et du nombre de pièces de puzzle à comparer, ce qui peut rendre l'algorithme coûteux en temps et en espace pour
                    de grands dessins ou un grand nombre de pièces.
                </p>
            </div>
        </div>

        <div class="box">
            <span></span>
            <div class="content_explications_fonctions">
                <h2>Code PYTHON</h2>
                <pre>
def raisonnement(defis):
    drawing = defis["drawing"]
    pieces = defis["pieces"]

    # On regarde si il y a possibilité d'enlever des colonnes à droite du dessin
    decalage = decalage_raisonnement(drawing)

    # On décale chaque ligne du dessin par "decalage"
    new_drawing = [ligne[decalage:] for ligne in drawing if "" in ligne]

    # On regarde si il y a possibilité d'enlever des colonnes à gauche du dessin mais pour cela on va inverser chaque ligne du dessin
    new_drawing = retourne_raisonnement(new_drawing)
    # On regarde si il y a possibilité d'enlever des colonnes à droite du dessin
    decalage_new_drawing = decalage_raisonnement(new_drawing)

    # On décale chaque ligne du dessin par "decalage_new_drawing"
    finish_drawing = [ligne[decalage_new_drawing:] for ligne in new_drawing if "" in ligne]

    # On remet le dessin à l'endroit
    finish_drawing = retourne_raisonnement(finish_drawing)
    # On inverse le vide ("") avec les murs ("X")
    finish_drawing = inversion_raisonnement(finish_drawing)
    # On regarde si une solution est possible
    for nom, map in pieces.items():
        if finish_drawing == map:
            return nom

    return "Aucune de ces solutions n'est la bonne"



def decalage_raisonnement(drawing):
    possibilite_decalage = []
    arrete_for = False
    # On parcourt chaque ligne de "drawing"
    for ligne in drawing:
        decalage = 0
        compteur = 0 # Pour savoir si on est au début de la ligne
        # On parcourt chaque symbole surla ligne
        for symbole in ligne:
            # Si le symbole est un trou et qu'il se trouve au début de la ligne
            if (symbole == "") and (compteur == 0):
                decalage = 0
                return decalage
            elif symbole == "X":
                decalage += 1
            # Sinon on arrête les boucles "for"
            else:
                possibilite_decalage.append(decalage)
                break
            
            compteur += 1

        if arrete_for:
            break

    return min(possibilite_decalage)



def retourne_raisonnement(drawing):
    new_drawing = []
    for ligne in drawing:
        new_drawing.append(ligne[::-1])

    return new_drawing



def inversion_raisonnement(drawing):
    for ligne in range(len(drawing)):
        for colonne in range(len(drawing[ligne])):
            if drawing[ligne][colonne] == "":
                drawing[ligne][colonne] = "X"
            else:
                drawing[ligne][colonne] = ""
    return drawing
                </pre>
            </div>
        </div>
    </div>

    <footer>
        <p>
            <a href="https://validator.w3.org/nu/?doc=https%3A%2F%2Fbrunbrun24.github.io%2FCortex-Challenge%2Fsujet.html" target="_blank">
                <img src="https://raw.githubusercontent.com/bradleytaunt/html5-valid-badge/68b012b5c19b26f75d9bee2409420c916b2d451a/html5-validator-badge.svg" alt="HTML5 Valide !">
            </a>
        </p>
        <p>
            <a href="https://jigsaw.w3.org/css-validator/validator?uri=https%3A%2F%2Fbrunbrun24.github.io%2FCortex-Challenge%2Fsujet.html&profile=css3svg&usermedium=all&warning=1&vextwarning=&lang=fr" target="_blank">
                <img src="https://jigsaw.w3.org/css-validator/images/vcss" alt="CSS Valide !">
            </a>
        </p>
    </footer>
    
</body>
</html>